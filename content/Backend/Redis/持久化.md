### 持久化简介
利用永久性存储介质将数据进行保存,在特定的时间将保存的数据进行恢复的工作机制称为持久化。

- 防止数据流失,将当前数据状态进行保存,快照形式,存储数据结果,存储格式简单,关注点在数据。 RDB
- 将数据的操作过程进行保存,日志形式,存储操作过程,存储格式复杂,关注点在数据的操作过程。 AOF


### RDB启动方式
命令执行: 谁:redis操作者, 什么时间:即时,干什么事情:保存数据

save指令工作原理:
如果是多个客户端对应一个服务端,那么客户端的命令会以单线程执行队列的方式进行,会造成当前服务器阻塞,直到RDB当前任务过程完成.


- 数据量过大,单线程执行方式造成效率过低如何处理?
- 后台执行 -bssave指令 会在后台保证操作。
```
1. 发送指令
2. 调用fork()生成子进程
3. 创建RDB文件
4. 返回消息
5. 返回消息
```

- 注意:bgsave命令是针对save阻塞问题做的优化,Redis内部所有涉及到RDB的操作都采用bgsave的命令

配置

```
save second changes
second: 监控时间范围
changes: 监控key的变化量
满足限定时间范围内key的变化数量达到指定数量进行持久化
```


### RDB的优点与缺点

- 优点
RDB是一个紧凑压缩的二进制文件,存储效率较高
RDB内部存储的是REDIS在某个时间点的数据快照,非常适用于备份,全量复制的场景
RDB恢复数据的速度要比AOF快很多

- 缺点
RDB无论是执行指令还是利用配置,无法做到实时持久化有很大可能丢了数据
bgsave指令每次运行要执行fork()操作创建子进程,要牺牲掉性能
有可能出现各版本之间的数据无法兼容的情况


## AOF概念
AOF(append only file)持久化: 以独立日志的方式记录每次写命令,重启时再重新执行AOF文件中的命令,达到恢复数据的目的。与RDB相比描述为改记录数据为记录数据产生的过程



 - AOF 写数据三种策略
    - always(每次) ： 数据零误差,性能差
    - everysec(每秒)：数据准确性较高,性能较高
    - no(系统控制): 由系统控制每次同步到AOF文件的周期,整体过程不可控
    
```
appendfilename filename - AOF持久化文件名
dir - AOF持久化保存路径与RDB持久化文件保持一致即可
appendonly yes/no 
appendfsync: always,everysec,no

```

## AOF重写

随着命令不断写入AOF,文件会越来越大,为了解决这个问题,Redis引入了AOF重写机制压缩文件体积。 AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。

- AOF 重写的作用
 - 降低磁盘占用量,提高磁盘利用率
 - 提高持久化效率,降低持久化时间,提高IO性能
 - 降低数据恢复用时,提高数据恢复效率
 
```
手动重写: bgrewriteaof

自动重写: auto-aof-rewrite-min-size size
         auto-aof-rewrite-percentage percentage

自动重写触发比对参数: aof_current_size / aof_base_size
       
```

- AOF工作流程
   执行指令set -> 主进程 -> 执行set 
              ｜fork() -> 非重写.aof
   
